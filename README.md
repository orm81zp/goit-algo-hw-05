# Домашнє завдання 5

## Опис


## Виконання

Домашнє завдання виконано у файлі main.py.

Наступні параметри будуть використані за замовчуванням, якщо не було передано з командного рядку жодного:

-   кількість спроб: `1`
-   набори даних: `100,1000,10000`

## Зміст

-   [Приклад запуску програми](#приклад-запуску-програми)
-   [Приклад роботи програми](#приклад-роботи-програми)
-   [Алгоритм злиттям](#алгоритм-злиттям)
-   [Алгоритм вставками](#алгоритм-вставками)
-   [Алгоритм Timsort](#алгоритм-timsort)
-   [Висновки](#висновки)

## Приклад запуску програми

```
python main.py [кількість спроб] [набори даних через кому]
```

```
python main.py 1
python main.py 1 100,1000,10000
```

## Приклад роботи програми

```
Кількість спроб: 1
Набори даних: [100, 1000, 10000]

Середній час:
merge_sort: 0.020695
insertion_sort: 2.030430
sorted: 0.001031

Порівняння:
sorted працює 20.1 разів швидше ніж merge_sort.
sorted працює 1970.2 разів швидше ніж insertion_sort.
```

## Алгоритм злиттям

Ефективний метод сортування, який використовує принцип "розділяй та володарюй". Його розробив американський математик Джон фон Нейман у 1945 році. Він розбиває масив на дві половини, сортує їх окремо, а потім зливає їх, щоб отримати відсортований масив. Це забезпечує надійну й стабільну процедуру сортування з гарантованою часовою складністю $O(n \cdot  \log n)$

## Алгоритм вставками

використовує ідею, подібну до тієї, яку використовують люди при сортуванні гральних карт: ви берете одну карту за раз і вставляєте її на правильне місце в ряду карт, які у вас вже є в руках. Цей метод є дуже ефективним для невеликих наборів даних і наборів даних, які вже частково впорядковані.

Цей метод працює шляхом розбиття списку на відсортовану та несортовану частини. На кожному кроці він бере наступний елемент із несортованої частини і вставляє його на відповідне місце в сортованій частині. Часова складність — $O(n^2)$.

## Алгоритм Timsort

Це гібридний алгоритм сортування, який комбінує розглянуті нами алгоритми сортування вставкою (Insertion Sort) та злиттям (Merge Sort). Алгоритм був розроблений Тімом Пітерсом у 2002 році для використання в мові програмування Python (він є основним алгоритмом сортування в стандартній бібліотеці Python).

Масив розділяється на невеликі "пробіжки" (runs), які потім сортуються за допомогою сортування вставкою. Відсортовані пробіжки зливаються в більші відсортовані масиви за допомогою сортування злиттям. Процес злиття продовжується, поки весь масив не стане повністю відсортованим.

Алгоритм має такі характеристики:

-   Часова складність: $O(n \cdot  \log n)$ у загальному випадку, $O(n)$ для вже відсортованих даних

-   Просторова складність: $O(n)$

## Висновки

Як можемо бачити з тесту, алгоритм вставками займає найбільше часу тому що має найбільшу часову складність $O(n^2)$. А найбільш ефективним виявився алгоритм сортування Timsort (вбудована у Python функція sorted), який комбінує розглянуті у тестах алгоритми і має часову складність $O(n \cdot  \log n)$ у загальному випадку та просторову складність $O(n)$. Є стабільним алгоритмом сортування.

На момент тестування функція sorted() працювала у 20 разів швидше ніж merge_sort та у 1970 разів швидше ніж insertion_sort.

Сортування є стабільним, якщо воно гарантує відсутність зміни відносного порядку порівнюваних рівних елементів — це корисно для сортування за кілька проходів. Алгоритм сортування використовує лише < порівняння між елементами.

За допомогою наведеного вище коду ми можете експериментально підтвердити часові складності застосованих алгоритмів сортування.

Як загальний висновок - алгоритм Timsort є набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі.
